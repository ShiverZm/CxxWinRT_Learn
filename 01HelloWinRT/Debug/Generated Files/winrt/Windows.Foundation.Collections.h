// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.190404.8

#ifndef WINRT_Windows_Foundation_Collections_H
#define WINRT_Windows_Foundation_Collections_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.190404.8"), "Mismatched C++/WinRT headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
namespace winrt::impl
{
    template <typename D, typename T> Windows::Foundation::Collections::IIterator<T> consume_Windows_Foundation_Collections_IIterable<D, T>::First() const
    {
        void* winrt_impl_result{};
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IIterable<T>)->First(&winrt_impl_result));
        return { winrt_impl_result, take_ownership_from_abi };
    }
    template <typename D, typename T> T consume_Windows_Foundation_Collections_IIterator<D, T>::Current() const
    {
        T winrt_impl_result{ empty_value<T>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IIterator<T>)->get_Current(put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename T> bool consume_Windows_Foundation_Collections_IIterator<D, T>::HasCurrent() const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IIterator<T>)->get_HasCurrent(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> bool consume_Windows_Foundation_Collections_IIterator<D, T>::MoveNext() const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IIterator<T>)->MoveNext(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> uint32_t consume_Windows_Foundation_Collections_IIterator<D, T>::GetMany(array_view<T> items) const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IIterator<T>)->GetMany(items.size(), put_abi(items), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> K consume_Windows_Foundation_Collections_IKeyValuePair<D, K, V>::Key() const
    {
        K winrt_impl_result{ empty_value<K>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IKeyValuePair<K, V>)->get_Key(put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> V consume_Windows_Foundation_Collections_IKeyValuePair<D, K, V>::Value() const
    {
        V winrt_impl_result{ empty_value<V>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IKeyValuePair<K, V>)->get_Value(put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K> Windows::Foundation::Collections::CollectionChange consume_Windows_Foundation_Collections_IMapChangedEventArgs<D, K>::CollectionChange() const
    {
        Windows::Foundation::Collections::CollectionChange winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapChangedEventArgs<K>)->get_CollectionChange(put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K> K consume_Windows_Foundation_Collections_IMapChangedEventArgs<D, K>::Key() const
    {
        K winrt_impl_result{ empty_value<K>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapChangedEventArgs<K>)->get_Key(put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> V consume_Windows_Foundation_Collections_IMapView<D, K, V>::Lookup(impl::param_type<K> const& key) const
    {
        V winrt_impl_result{ empty_value<V>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapView<K, V>)->Lookup(get_abi(key), put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> uint32_t consume_Windows_Foundation_Collections_IMapView<D, K, V>::Size() const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapView<K, V>)->get_Size(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> bool consume_Windows_Foundation_Collections_IMapView<D, K, V>::HasKey(impl::param_type<K> const& key) const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapView<K, V>)->HasKey(get_abi(key), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> void consume_Windows_Foundation_Collections_IMapView<D, K, V>::Split(Windows::Foundation::Collections::IMapView<K, V>& first, Windows::Foundation::Collections::IMapView<K, V>& second) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMapView<K, V>)->Split(put_abi(first), put_abi(second)));
    }
    template <typename D, typename K, typename V> V consume_Windows_Foundation_Collections_IMap<D, K, V>::Lookup(impl::param_type<K> const& key) const
    {
        V winrt_impl_result{ empty_value<V>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->Lookup(get_abi(key), put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> uint32_t consume_Windows_Foundation_Collections_IMap<D, K, V>::Size() const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->get_Size(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> bool consume_Windows_Foundation_Collections_IMap<D, K, V>::HasKey(impl::param_type<K> const& key) const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->HasKey(get_abi(key), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> Windows::Foundation::Collections::IMapView<K, V> consume_Windows_Foundation_Collections_IMap<D, K, V>::GetView() const
    {
        void* winrt_impl_result{};
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->GetView(&winrt_impl_result));
        return { winrt_impl_result, take_ownership_from_abi };
    }
    template <typename D, typename K, typename V> bool consume_Windows_Foundation_Collections_IMap<D, K, V>::Insert(impl::param_type<K> const& key, impl::param_type<V> const& value) const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->Insert(get_abi(key), get_abi(value), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> void consume_Windows_Foundation_Collections_IMap<D, K, V>::Remove(impl::param_type<K> const& key) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->Remove(get_abi(key)));
    }
    template <typename D, typename K, typename V> void consume_Windows_Foundation_Collections_IMap<D, K, V>::Clear() const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IMap<K, V>)->Clear());
    }
    template <typename D, typename K, typename V> winrt::event_token consume_Windows_Foundation_Collections_IObservableMap<D, K, V>::MapChanged(Windows::Foundation::Collections::MapChangedEventHandler<K, V> const& vhnd) const
    {
        winrt::event_token winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IObservableMap<K, V>)->add_MapChanged(get_abi(vhnd), put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename K, typename V> typename consume_Windows_Foundation_Collections_IObservableMap<D, K, V>::MapChanged_revoker consume_Windows_Foundation_Collections_IObservableMap<D, K, V>::MapChanged(auto_revoke_t, Windows::Foundation::Collections::MapChangedEventHandler<K, V> const& vhnd) const
    {
        return impl::make_event_revoker<D, MapChanged_revoker>(this, MapChanged(vhnd));
    }
    template <typename D, typename K, typename V> void consume_Windows_Foundation_Collections_IObservableMap<D, K, V>::MapChanged(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_SHIM(Windows::Foundation::Collections::IObservableMap<K, V>)->remove_MapChanged(get_abi(token)));
    }
    template <typename D, typename T> winrt::event_token consume_Windows_Foundation_Collections_IObservableVector<D, T>::VectorChanged(Windows::Foundation::Collections::VectorChangedEventHandler<T> const& vhnd) const
    {
        winrt::event_token winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IObservableVector<T>)->add_VectorChanged(get_abi(vhnd), put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename T> typename consume_Windows_Foundation_Collections_IObservableVector<D, T>::VectorChanged_revoker consume_Windows_Foundation_Collections_IObservableVector<D, T>::VectorChanged(auto_revoke_t, Windows::Foundation::Collections::VectorChangedEventHandler<T> const& vhnd) const
    {
        return impl::make_event_revoker<D, VectorChanged_revoker>(this, VectorChanged(vhnd));
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IObservableVector<D, T>::VectorChanged(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_SHIM(Windows::Foundation::Collections::IObservableVector<T>)->remove_VectorChanged(get_abi(token)));
    }
    template <typename D> Windows::Foundation::Collections::CollectionChange consume_Windows_Foundation_Collections_IVectorChangedEventArgs<D>::CollectionChange() const
    {
        Windows::Foundation::Collections::CollectionChange value;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorChangedEventArgs)->get_CollectionChange(put_abi(value)));
        return value;
    }
    template <typename D> uint32_t consume_Windows_Foundation_Collections_IVectorChangedEventArgs<D>::Index() const
    {
        uint32_t value;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorChangedEventArgs)->get_Index(&value));
        return value;
    }
    template <typename D, typename T> T consume_Windows_Foundation_Collections_IVectorView<D, T>::GetAt(uint32_t index) const
    {
        T winrt_impl_result{ empty_value<T>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorView<T>)->GetAt(index, put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename T> uint32_t consume_Windows_Foundation_Collections_IVectorView<D, T>::Size() const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorView<T>)->get_Size(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> bool consume_Windows_Foundation_Collections_IVectorView<D, T>::IndexOf(impl::param_type<T> const& value, uint32_t& index) const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorView<T>)->IndexOf(get_abi(value), &index, &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> uint32_t consume_Windows_Foundation_Collections_IVectorView<D, T>::GetMany(uint32_t startIndex, array_view<T> items) const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVectorView<T>)->GetMany(startIndex, items.size(), put_abi(items), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> T consume_Windows_Foundation_Collections_IVector<D, T>::GetAt(uint32_t index) const
    {
        T winrt_impl_result{ empty_value<T>() };
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->GetAt(index, put_abi(winrt_impl_result)));
        return winrt_impl_result;
    }
    template <typename D, typename T> uint32_t consume_Windows_Foundation_Collections_IVector<D, T>::Size() const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->get_Size(&winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> Windows::Foundation::Collections::IVectorView<T> consume_Windows_Foundation_Collections_IVector<D, T>::GetView() const
    {
        void* winrt_impl_result{};
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->GetView(&winrt_impl_result));
        return { winrt_impl_result, take_ownership_from_abi };
    }
    template <typename D, typename T> bool consume_Windows_Foundation_Collections_IVector<D, T>::IndexOf(impl::param_type<T> const& value, uint32_t& index) const
    {
        bool winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->IndexOf(get_abi(value), &index, &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::SetAt(uint32_t index, impl::param_type<T> const& value) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->SetAt(index, get_abi(value)));
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::InsertAt(uint32_t index, impl::param_type<T> const& value) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->InsertAt(index, get_abi(value)));
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::RemoveAt(uint32_t index) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->RemoveAt(index));
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::Append(impl::param_type<T> const& value) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->Append(get_abi(value)));
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::RemoveAtEnd() const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->RemoveAtEnd());
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::Clear() const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->Clear());
    }
    template <typename D, typename T> uint32_t consume_Windows_Foundation_Collections_IVector<D, T>::GetMany(uint32_t startIndex, array_view<T> items) const
    {
        uint32_t winrt_impl_result;
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->GetMany(startIndex, items.size(), put_abi(items), &winrt_impl_result));
        return winrt_impl_result;
    }
    template <typename D, typename T> void consume_Windows_Foundation_Collections_IVector<D, T>::ReplaceAll(array_view<T const> items) const
    {
        check_hresult(WINRT_SHIM(Windows::Foundation::Collections::IVector<T>)->ReplaceAll(items.size(), get_abi(items)));
    }
    template <typename K, typename V> struct delegate<Windows::Foundation::Collections::MapChangedEventHandler<K, V>>
    {
        template <typename H>
        struct type : implements_delegate<Windows::Foundation::Collections::MapChangedEventHandler<K, V>, H>
        {
            type(H&& handler) : implements_delegate<Windows::Foundation::Collections::MapChangedEventHandler<K, V>, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(void* sender, void* event) noexcept final
            {
                try
                {
                    (*this)(*reinterpret_cast<Windows::Foundation::Collections::IObservableMap<K, V> const*>(&sender), *reinterpret_cast<Windows::Foundation::Collections::IMapChangedEventArgs<K> const*>(&event));
                    return 0;
                }
                catch (...)
                {
                    return to_hresult();
                }
            }
        };
    };
    template <typename T> struct delegate<Windows::Foundation::Collections::VectorChangedEventHandler<T>>
    {
        template <typename H>
        struct type : implements_delegate<Windows::Foundation::Collections::VectorChangedEventHandler<T>, H>
        {
            type(H&& handler) : implements_delegate<Windows::Foundation::Collections::VectorChangedEventHandler<T>, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(void* sender, void* event) noexcept final
            {
                try
                {
                    (*this)(*reinterpret_cast<Windows::Foundation::Collections::IObservableVector<T> const*>(&sender), *reinterpret_cast<Windows::Foundation::Collections::IVectorChangedEventArgs const*>(&event));
                    return 0;
                }
                catch (...)
                {
                    return to_hresult();
                }
            }
        };
    };
    template <typename D, typename T>
    struct produce<D, Windows::Foundation::Collections::IIterable<T>> : produce_base<D, Windows::Foundation::Collections::IIterable<T>>
    {
        int32_t WINRT_CALL First(void** winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<Windows::Foundation::Collections::IIterator<T>>(this->shim().First());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename T>
    struct produce<D, Windows::Foundation::Collections::IIterator<T>> : produce_base<D, Windows::Foundation::Collections::IIterator<T>>
    {
        int32_t WINRT_CALL get_Current(arg_out<T> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<T>(this->shim().Current());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_HasCurrent(bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().HasCurrent());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL MoveNext(bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().MoveNext());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL GetMany(uint32_t __itemsSize, arg_out<T> items, uint32_t* winrt_impl_result) noexcept final try
        {
            zero_abi<T>(items, __itemsSize);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().GetMany(array_view<T>(reinterpret_cast<T*>(items), reinterpret_cast<T*>(items) + __itemsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename K, typename V>
    struct produce<D, Windows::Foundation::Collections::IKeyValuePair<K, V>> : produce_base<D, Windows::Foundation::Collections::IKeyValuePair<K, V>>
    {
        int32_t WINRT_CALL get_Key(arg_out<K> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<K>(this->shim().Key());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Value(arg_out<V> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<V>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename K>
    struct produce<D, Windows::Foundation::Collections::IMapChangedEventArgs<K>> : produce_base<D, Windows::Foundation::Collections::IMapChangedEventArgs<K>>
    {
        int32_t WINRT_CALL get_CollectionChange(int32_t* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<Windows::Foundation::Collections::CollectionChange>(this->shim().CollectionChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Key(arg_out<K> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<K>(this->shim().Key());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename K, typename V>
    struct produce<D, Windows::Foundation::Collections::IMapView<K, V>> : produce_base<D, Windows::Foundation::Collections::IMapView<K, V>>
    {
        int32_t WINRT_CALL Lookup(arg_in<K> key, arg_out<V> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<V>(this->shim().Lookup(*reinterpret_cast<K const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Size(uint32_t* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL HasKey(arg_in<K> key, bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().HasKey(*reinterpret_cast<K const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Split(void** first, void** second) noexcept final try
        {
            clear_abi(first);
            clear_abi(second);
            typename D::abi_guard guard(this->shim());
            this->shim().Split(*reinterpret_cast<Windows::Foundation::Collections::IMapView<K, V>*>(first), *reinterpret_cast<Windows::Foundation::Collections::IMapView<K, V>*>(second));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename K, typename V>
    struct produce<D, Windows::Foundation::Collections::IMap<K, V>> : produce_base<D, Windows::Foundation::Collections::IMap<K, V>>
    {
        int32_t WINRT_CALL Lookup(arg_in<K> key, arg_out<V> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<V>(this->shim().Lookup(*reinterpret_cast<K const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Size(uint32_t* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL HasKey(arg_in<K> key, bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().HasKey(*reinterpret_cast<K const*>(&key)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL GetView(void** winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<Windows::Foundation::Collections::IMapView<K, V>>(this->shim().GetView());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Insert(arg_in<K> key, arg_in<V> value, bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().Insert(*reinterpret_cast<K const*>(&key), *reinterpret_cast<V const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Remove(arg_in<K> key) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Remove(*reinterpret_cast<K const*>(&key));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Clear() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Clear();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename K, typename V>
    struct produce<D, Windows::Foundation::Collections::IObservableMap<K, V>> : produce_base<D, Windows::Foundation::Collections::IObservableMap<K, V>>
    {
        int32_t WINRT_CALL add_MapChanged(void* vhnd, winrt::event_token* winrt_impl_result) noexcept final try
        {
            zero_abi<winrt::event_token>(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<winrt::event_token>(this->shim().MapChanged(*reinterpret_cast<Windows::Foundation::Collections::MapChangedEventHandler<K, V> const*>(&vhnd)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL remove_MapChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MapChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
    template <typename D, typename T>
    struct produce<D, Windows::Foundation::Collections::IObservableVector<T>> : produce_base<D, Windows::Foundation::Collections::IObservableVector<T>>
    {
        int32_t WINRT_CALL add_VectorChanged(void* vhnd, winrt::event_token* winrt_impl_result) noexcept final try
        {
            zero_abi<winrt::event_token>(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<winrt::event_token>(this->shim().VectorChanged(*reinterpret_cast<Windows::Foundation::Collections::VectorChangedEventHandler<T> const*>(&vhnd)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL remove_VectorChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VectorChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
    template <typename D>
    struct produce<D, Windows::Foundation::Collections::IPropertySet> : produce_base<D, Windows::Foundation::Collections::IPropertySet>
    {
    };
    template <typename D>
    struct produce<D, Windows::Foundation::Collections::IVectorChangedEventArgs> : produce_base<D, Windows::Foundation::Collections::IVectorChangedEventArgs>
    {
        int32_t WINRT_CALL get_CollectionChange(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::CollectionChange>(this->shim().CollectionChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Index(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().Index());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename T>
    struct produce<D, Windows::Foundation::Collections::IVectorView<T>> : produce_base<D, Windows::Foundation::Collections::IVectorView<T>>
    {
        int32_t WINRT_CALL GetAt(uint32_t index, arg_out<T> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<T>(this->shim().GetAt(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Size(uint32_t* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL IndexOf(arg_in<T> value, uint32_t* index, bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().IndexOf(*reinterpret_cast<T const*>(&value), *index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL GetMany(uint32_t startIndex, uint32_t __itemsSize, arg_out<T> items, uint32_t* winrt_impl_result) noexcept final try
        {
            zero_abi<T>(items, __itemsSize);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().GetMany(startIndex, array_view<T>(reinterpret_cast<T*>(items), reinterpret_cast<T*>(items) + __itemsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D, typename T>
    struct produce<D, Windows::Foundation::Collections::IVector<T>> : produce_base<D, Windows::Foundation::Collections::IVector<T>>
    {
        int32_t WINRT_CALL GetAt(uint32_t index, arg_out<T> winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<T>(this->shim().GetAt(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL get_Size(uint32_t* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL GetView(void** winrt_impl_result) noexcept final try
        {
            clear_abi(winrt_impl_result);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<Windows::Foundation::Collections::IVectorView<T>>(this->shim().GetView());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL IndexOf(arg_in<T> value, uint32_t* index, bool* winrt_impl_result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<bool>(this->shim().IndexOf(*reinterpret_cast<T const*>(&value), *index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL SetAt(uint32_t index, arg_in<T> value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetAt(index, *reinterpret_cast<T const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL InsertAt(uint32_t index, arg_in<T> value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InsertAt(index, *reinterpret_cast<T const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL RemoveAt(uint32_t index) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveAt(index);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Append(arg_in<T> value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Append(*reinterpret_cast<T const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL RemoveAtEnd() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveAtEnd();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL Clear() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Clear();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL GetMany(uint32_t startIndex, uint32_t __itemsSize, arg_out<T> items, uint32_t* winrt_impl_result) noexcept final try
        {
            zero_abi<T>(items, __itemsSize);
            typename D::abi_guard guard(this->shim());
            *winrt_impl_result = detach_from<uint32_t>(this->shim().GetMany(startIndex, array_view<T>(reinterpret_cast<T*>(items), reinterpret_cast<T*>(items) + __itemsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t WINRT_CALL ReplaceAll(uint32_t __itemsSize, arg_out<T> items) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReplaceAll(array_view<T const>(reinterpret_cast<T const *>(items), reinterpret_cast<T const *>(items) + __itemsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
namespace winrt::Windows::Foundation::Collections
{
    inline PropertySet::PropertySet() :
        PropertySet(impl::call_factory<PropertySet>([](auto&& f) { return f.template ActivateInstance<PropertySet>(); }))
    {
    }
    inline StringMap::StringMap() :
        StringMap(impl::call_factory<StringMap>([](auto&& f) { return f.template ActivateInstance<StringMap>(); }))
    {
    }
    inline ValueSet::ValueSet() :
        ValueSet(impl::call_factory<ValueSet>([](auto&& f) { return f.template ActivateInstance<ValueSet>(); }))
    {
    }
    template <typename K, typename V> template <typename L> MapChangedEventHandler<K, V>::MapChangedEventHandler(L handler) :
        MapChangedEventHandler(impl::make_delegate<MapChangedEventHandler<K, V>>(std::forward<L>(handler)))
    {
    }
    template <typename K, typename V> template <typename F> MapChangedEventHandler<K, V>::MapChangedEventHandler(F* handler) :
        MapChangedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename K, typename V> template <typename O, typename M> MapChangedEventHandler<K, V>::MapChangedEventHandler(O* object, M method) :
        MapChangedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename K, typename V> template <typename O, typename M> MapChangedEventHandler<K, V>::MapChangedEventHandler(com_ptr<O>&& object, M method) :
        MapChangedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename K, typename V> template <typename O, typename M> MapChangedEventHandler<K, V>::MapChangedEventHandler(weak_ref<O>&& object, M method) :
        MapChangedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    template <typename K, typename V> void MapChangedEventHandler<K, V>::operator()(Windows::Foundation::Collections::IObservableMap<K, V> const& sender, Windows::Foundation::Collections::IMapChangedEventArgs<K> const& event) const
    {
        check_hresult((*(impl::abi_t<MapChangedEventHandler<K, V>>**)this)->Invoke(get_abi(sender), get_abi(event)));
    }
    template <typename T> template <typename L> VectorChangedEventHandler<T>::VectorChangedEventHandler(L handler) :
        VectorChangedEventHandler(impl::make_delegate<VectorChangedEventHandler<T>>(std::forward<L>(handler)))
    {
    }
    template <typename T> template <typename F> VectorChangedEventHandler<T>::VectorChangedEventHandler(F* handler) :
        VectorChangedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename T> template <typename O, typename M> VectorChangedEventHandler<T>::VectorChangedEventHandler(O* object, M method) :
        VectorChangedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename T> template <typename O, typename M> VectorChangedEventHandler<T>::VectorChangedEventHandler(com_ptr<O>&& object, M method) :
        VectorChangedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename T> template <typename O, typename M> VectorChangedEventHandler<T>::VectorChangedEventHandler(weak_ref<O>&& object, M method) :
        VectorChangedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    template <typename T> void VectorChangedEventHandler<T>::operator()(Windows::Foundation::Collections::IObservableVector<T> const& sender, Windows::Foundation::Collections::IVectorChangedEventArgs const& event) const
    {
        check_hresult((*(impl::abi_t<VectorChangedEventHandler<T>>**)this)->Invoke(get_abi(sender), get_abi(event)));
    }
}
namespace std
{
    template<typename T> struct hash<winrt::Windows::Foundation::Collections::IIterable<T>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IIterable<T>> {};
    template<typename T> struct hash<winrt::Windows::Foundation::Collections::IIterator<T>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IIterator<T>> {};
    template<typename K, typename V> struct hash<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IKeyValuePair<K, V>> {};
    template<typename K> struct hash<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IMapChangedEventArgs<K>> {};
    template<typename K, typename V> struct hash<winrt::Windows::Foundation::Collections::IMapView<K, V>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IMapView<K, V>> {};
    template<typename K, typename V> struct hash<winrt::Windows::Foundation::Collections::IMap<K, V>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IMap<K, V>> {};
    template<typename K, typename V> struct hash<winrt::Windows::Foundation::Collections::IObservableMap<K, V>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IObservableMap<K, V>> {};
    template<typename T> struct hash<winrt::Windows::Foundation::Collections::IObservableVector<T>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IObservableVector<T>> {};
    template<> struct hash<winrt::Windows::Foundation::Collections::IPropertySet> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IPropertySet> {};
    template<> struct hash<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IVectorChangedEventArgs> {};
    template<typename T> struct hash<winrt::Windows::Foundation::Collections::IVectorView<T>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IVectorView<T>> {};
    template<typename T> struct hash<winrt::Windows::Foundation::Collections::IVector<T>> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::IVector<T>> {};
    template<> struct hash<winrt::Windows::Foundation::Collections::PropertySet> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::PropertySet> {};
    template<> struct hash<winrt::Windows::Foundation::Collections::StringMap> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::StringMap> {};
    template<> struct hash<winrt::Windows::Foundation::Collections::ValueSet> : winrt::impl::hash_base<winrt::Windows::Foundation::Collections::ValueSet> {};
}
#endif
